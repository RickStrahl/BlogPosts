<!DOCTYPE html>
<html lang="en">
<head>
    <base href="file:///C:/Users/rstrahl/DropBox/Markdown%20Monster%20Weblog%20Posts/2024-03/Comparing%20Raw%20ASP.NET%20Request%20Throughput%20across%20Versions/"/>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta charset="utf-8"/>

    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <link href="file:///D:\projects\MarkdownMonsterCode\MarkdownMonster\bin\Release\net8.0-windows\PreviewThemes\Westwind\..\Scripts\fontawesome\css\font-awesome.min.css" rel="stylesheet"/>
    <link href="file:///D:\projects\MarkdownMonsterCode\MarkdownMonster\bin\Release\net8.0-windows\PreviewThemes\Westwind\Theme.css" rel="stylesheet"/>


    <script src="file:///D:\projects\MarkdownMonsterCode\MarkdownMonster\bin\Release\net8.0-windows\PreviewThemes\Westwind\..\Scripts\jquery.min.js"></script>
    <link href="file:///D:\projects\MarkdownMonsterCode\MarkdownMonster\bin\Release\net8.0-windows\PreviewThemes\Westwind\..\Scripts\highlightjs\styles\vs2015.css" rel="stylesheet"/>
    <script src="file:///D:\projects\MarkdownMonsterCode\MarkdownMonster\bin\Release\net8.0-windows\PreviewThemes\Westwind\..\Scripts\highlightjs\highlight.pack.js"></script>
    <script src="file:///D:\projects\MarkdownMonsterCode\MarkdownMonster\bin\Release\net8.0-windows\PreviewThemes\Westwind\..\Scripts\highlightjs-badge.js"></script>
    <script src="file:///D:\projects\MarkdownMonsterCode\MarkdownMonster\bin\Release\net8.0-windows\PreviewThemes\Westwind\..\Scripts\preview.js" id="PreviewScript"></script>

    

</head>
<body>
<div id="MainContent">
  <!-- Markdown Monster Content -->
  <h1 id="comparing-raw-aspnet-request-throughput-across-versions">Comparing Raw ASP.NET Request Throughput across Versions</h1>
<p><img src="NewAndOldComputers.jpg" alt="New And Old Computers" /></p>
<p>It's that time of year again to upgrade to a new machine, and one of the first things I often do once the machine is set up is run some performance tests of a simple ASP.NET application that tests raw request throughput of a couple of JSON do-nothing requests.</p>
<p>Mind you, this isn't indicative of any kind of real world application performance, but it's a pretty good yardstick to compare rough performance across .NET versions and my local computers, and how well it performs across versions and machines.</p>
<p>To me this is one of those apples to apples comparison when running the same app, on the same type of environment. It's not going to compare to anything other than that - so take what I write here in that context, and you can run these tests yourself on your own machines and setups and compare. This is a very simple project with literally 4 requests - 2 minimal API endpoints and 2 controller API endpoints.</p>
<ul>
<li><a href="https://github.com/RickStrahl/HighPerformanceAspNet">Project on GitHub</a></li>
</ul>
<p>Stupidly simple but I find this very practical to go through, even though this doesn't qualify as 'scientific' testing. It's merely a yardstick I can calibrate performance to, by comparing past and present results.</p>
<h2 id="another-day-another-new-machine">Another Day another New Machine</h2>
<p>All of this has been brought on by my need to get a new dev machine recently. I've been having issues with my 12th gen Dell XPS laptop which is a few years old now. It's an I7 12th gen machine, with 32gb and a fast hard drive. It runs well enough for most day to day tasks, but for development and some testing tasks like this, the XPS runs into serious issues with overheating and CPU throttling. Extended use of Visual Studio and Resharper too, will often bring the XPS to its knees to where even typing becomes a problem.</p>
<p>So finally I decided to get a new machine and instead of getting another Dell. I decided I need a larger (ie. voluminous) laptop that can actually handle the heat and also go up to an I9 processor with more cores and better sustained performance. I ended up getting a relatively cheap gaming laptop - from CostCo no less (ha ha) - threw in Windows Pro and a faster and bigger drive, and paved the box without all the crap ware and gaming doodahs. I ended up with what seems to be one screamer of a machine for a lot less than a new XPS or other signature laptop would be, much less one with matching hardware.</p>
<p><a href="https://www.costco.com/msi-ge68hx-raider-16%22-gaming-laptop---13th-gen-intel-core-i9-13950hx---geforce-rtx-4060---144hz-fhd%2b-1920-x-1200.product.4000139317.html">MSI GE68HX Raider (CostCo)</a></p>
<p>CostCo was running a big discount on this, but unfortunately it's back to full price now. Even so it seems like a decent deal for this hardware. It's likely discounted as the new 14th gen chips are starting to roll out at nearly twice the price (for what looks only marginal performance gains in 14th gen).</p>
<p>There are also lots of combos of this machine on Amazon like this one:</p>
<p><a href="https://amzn.to/48MjzCc">MSI GE68HX Raider (on Amazon)</a></p>
<p>The difference in performance from the XPS and the lack of throttling is immediately noticeable. Using Visual Studio with Resharper (arguably the most resource intensive client task on the planet 😁) is much smoother, along with noticeably more snappy all around operation. As is to be expected - it's not just the faster CPU with even more threads, but also the fact that this machine is big and has some serious cooling hardware inside with vents everywhere - this thing is much better suited to handle heat dissipation than the wafer thin XPS. So far I've seen no heat throttling even in our Maui non-AC environment which can get a little spicy at times.</p>
<h2 id="testing-with-aspnet">Testing with ASP.NET</h2>
<p>Anyway... one of the things I do is run these perf tests with this super simplistic ASP.NET application that basically creates a few do-nothing JSON API requests. I started this a long time ago with Classic ASP.NET and over the years have continued to update the Web app to reflect newer versions of .NET. There's no special optimization, just a few endpoints that spit back some dynamic JSON for both GET and POST operations.</p>
<p>Over the years the numbers have gone up and up as both hardware and .NET have improved.</p>
<p>For this iteration, I broke out the tests for .NET 7 and now 8 and split up the app into both Minimal API endpoints and Mvc Controllers as these have different performance characteristics.</p>
<h2 id="ultra-simple-requests">Ultra Simple Requests</h2>
<p>The idea here isn't to test real-world performance but to get a yardstick comparison of the simplest thing possible to push a request through the ASP.NET pipeline and compare across versions and machines. All this really measures is the throughput of the ASP.NET pipeline for the given mechanism - Minimal API or Controllers.</p>
<p>The code is simply:</p>
<h3 id="minimal-apis-endpoints">Minimal APIs EndPoints</h3>
<pre><code class="language-csharp">// inline in program.cs
app.MapGet(&quot;/hello&quot;, () =&gt;
{
    return new { name = &quot;Rick&quot;, message = &quot;Hello World&quot; };
});
app.MapPost(&quot;/hello&quot;, (RequestMessage model) =&gt;
{
    return new { name = model.Name, message = model.Message };
});
</code></pre>
<h3 id="controller-endpoints">Controller EndPoints</h3>
<pre><code class="language-csharp">[Route(&quot;[controller]&quot;)]
public class ClassicController : ControllerBase
{
    [HttpGet(&quot;hello&quot;)]
    public object Hello()
    {
        return new { name = &quot;Rick&quot;, message = &quot;Hello World&quot; };
    }

    [HttpPost(&quot;hello&quot;)]
    public object Hello(RequestMessage model)
    {
        return new { name = model.Name, message = model.Message };
    }
}
</code></pre>
<h2 id="running-the-web-app">Running the Web App</h2>
<p>Next I build the app and publish it locally then run the published app out of the publish folder and run it in production mode.</p>
<pre><code class="language-ps">dotnet publish HighPerformanceAspNet.csproj -o ../Publish -c Release
../publish/HighPerformanceAspNet --urls https://localhost:5200
</code></pre>
<p>Here's the app running in a Terminal:</p>
<p><img src="RunningApplication.png" alt="Running Application" /></p>
<p>You'll want to make sure you run your tests in <code>Production</code> mode to avoid overhead for logging and other trace information - development will slow things down significantly especially if Console logging kicks in.</p>
<blockquote>
<p>It's not required that you publish explicitly: You can use <code>dotnet run</code> as well, but you have to make sure you <strong>explicitly set up your Environment to <code>Production</code></strong> in <code>launchSettings.json</code> or via command line parameters.</p>
<p>Publishing automatically ensures you're using <code>Production</code> in the generated runtime config files.</p>
</blockquote>
<h2 id="testing-with-websurge-or-other-load-tester">Testing with WebSurge (or other load tester)</h2>
<p>To test request I use <a href="https://websurge.west-wind.com">West Wind WebSurge</a> (yes I'm biased 😁), but you can use any other load testing tool like <a href="https://github.com/codesenberg/bombardier">Bombardier</a>, <a href="https://jmeter.apache.org/">JMeter</a>, Visual Studio Test etc.</p>
<p>Load testing always depends on the specific environment that you're testing and that what you are testing from and with, so especially with an unscientific test like this, keep in mind that the performance numbers only mean anything in relation to each other. They give you a general idea of what a given set of hardware is capable of running the test.</p>
<p>I broke out these tests into four sets on each machine:</p>
<ul>
<li>One set for Minimal APIs</li>
<li>One Set for Controller APIs</li>
</ul>
<p>Then run both of those for:</p>
<ul>
<li>.NET 8</li>
<li>.NET 7</li>
</ul>
<p>Then repeat on both machines (the old XPS and the new MSI box).</p>
<h3 id="i9-msi-laptop">I9 MSI Laptop</h3>
<h4 id="i9---net-8---minimal-apis">I9 - .NET 8 - Minimal APIs</h4>
<p><img src="msi-i9-dotnet8-minimal-api.png" alt="msi i9 dotnet8 minimal api" /></p>
<h4 id="i9---net-8---controllers">I9 - .NET 8 - Controllers</h4>
<p><img src="msi-i9-dotnet8-controllers.png" alt="msi i9 dotnet8 controllers" /></p>
<h4 id="i9---net-7---minimal-apis">I9 - .NET 7 - Minimal APIs</h4>
<p><img src="msi-i9-dotnet7-minimal-api.png" alt="msi i9 dotnet7 minimal api" /></p>
<h4 id="i9---net-7---controllers">I9 - .NET 7 - Controllers</h4>
<p><img src="msi-i9-dotnet7-controllers.png" alt="msi i9 dotnet7 controllers" /></p>
<h3 id="dell-xps-i7-laptop">Dell XPS I7 Laptop</h3>
<h4 id="i7---net-8---minimal-apis">I7 - .NET 8 - Minimal APIs</h4>
<p><img src="dell-i7-dotnet8-minimal-api.png" alt="dell i7 dotnet8 minimal api" /></p>
<h4 id="i7---net-8---controllers">I7 - .NET 8 - Controllers</h4>
<p><img src="dell-i7-dotnet8-controllers.png" alt="dell i7 dotnet8 controllers" /></p>
<h4 id="i7---net-7---minimal-apis">I7 - .NET 7 - Minimal APIs</h4>
<p><img src="dell-i7-dotnet7-minimal-api.png" alt="dell i7 dotnet7 minimal api" /></p>
<h4 id="i7---net-7---controllers">I7 - .NET 7 - Controllers</h4>
<p><img src="dell-i7-dotnet7-controllers.png" alt="dell i7 dotnet7 controllers" /></p>
<p>A couple of things jump out of the results:</p>
<ul>
<li>The results are oddly consistent across machines and individual runs</li>
<li>Minimal APIs handles roughly slightly &gt;10% more than Controllers</li>
<li>.NET 8.0 handles roughly 10% more than .NET 7.0</li>
<li>This is a lot of requests handled on a local laptop!</li>
<li>The I7 Dell show the Thermal throttling kicking in 1/4 of the way into tests</li>
</ul>
<h4 id="a-little-more-info-on-the-test-run">A little more info on the Test Run</h4>
<p>Remember this all running on a local machine: both the server and the load tester are running on the same box. The test isn't particularly optimized either - finding an optimal set of simultaneous sessions (seems around 1.5-2x logical CPU count is usually optimal) could bump those numbers higher but it gets weird if there's too much load in the tester as it starts to interfere with the server CPU usage.</p>
<p>The tests run with no delays, essentially hammering requests as soon as the previous one completes. Each session runs sequentially (ie. 2 requests one after the other) then starts a new session.</p>
<h2 id="summary">Summary</h2>
<p>I'm pretty excited to see these kind of performance numbers from a &quot;laptop&quot; - even if it's just about the cartable size and heft. For a portable low to mid-range device to have this much horsepower to run these tests is impressive. Kudos to the hardware and .NET for taking it for all it's worth and putting it to work.</p>
<p>These numbers mean nothing other than a comparison against the other runs here and different environments. I find this type of tests useful to compare old and new versions of ASP.NET and different kinds of hardware, to see how the core engine processing of ASP.NET works. Nothing more nothing less.</p>
<p>I often also add in a few additional tests like running on IIS or under WSL to compare. Having a baseline project that I carry through generations can be useful to gauge basic performance over time. You can of course do this with your own actual projects too, but it's obviously  more complex with a fully configured application and getting it to run in a self-contained environment. A small project like this, running on native hardware without virtualization or container overhead is literally self contained and can just be run from the command line in full-on pedal-to-the-metal fashion just about anywhere that has the runtimes installed.</p>
<p>Now let's get back to work... 😁</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://github.com/RickStrahl/HighPerformanceAspNet">Project on GitHub</a></li>
<li><a href="https://websurge.west-wind.com">West Wind WebSurge</a></li>
</ul>
<div style="margin-top: 30px;font-size: 0.8em;
            border-top: 1px solid #eee;padding-top: 8px;">
    <img src="https://markdownmonster.west-wind.com/favicon.png"
         style="height: 20px;float: left; margin-right: 10px;"/>
    this post created and published with the 
    <a href="https://markdownmonster.west-wind.com" 
       target="top">Markdown Monster Editor</a> 
</div>

  <!-- End Markdown Monster Content -->
</div>

</body> 
</html>
